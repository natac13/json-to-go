package main

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"
)

type JsonToGo struct {
	data        interface{}
	scope       interface{}
	goCode      strings.Builder
	tabs        int
	seen        map[string]bool
	stack       []string
	accumulator string
	innerTabs   int
	parent      string
}

func NewJsonToGo(raw []byte) (*JsonToGo, error) {
	var data interface{}
	err := json.Unmarshal(raw, &data)
	if err != nil {
		fmt.Println("error parsing input JSON:", err)
		return nil, err
	}
	jsonToGo := &JsonToGo{
		data:        data,
		scope:       data,
		goCode:      strings.Builder{},
		tabs:        0,
		seen:        map[string]bool{},
		stack:       []string{},
		accumulator: "",
		innerTabs:   0,
		parent:      "",
	}

	return jsonToGo, nil
}

type Result struct {
	GoCode string
	Error  error
}

func (j *JsonToGo) Generate(typename string) Result {

	if typename == "" {
		typename = "AutoGenerated"
	}

	j.append(fmt.Sprintf("type %s ", typename))

	j.parseScope(j.scope)

	return Result{
		GoCode: j.goCode.String(),
		Error:  nil,
	}
}

func (j *JsonToGo) append(s string) {
	j.goCode.WriteString(s)
}

func (j *JsonToGo) indent(tabs int) {
	for i := 0; i < tabs; i++ {
		j.goCode.WriteString("\t")
	}
}

func (j *JsonToGo) appender(s string) {
	j.stack = append(j.stack, s)
}

func (j *JsonToGo) indenter(tags int) {
	for i := 0; i < tags; i++ {
		j.stack = append(j.stack, "\t")
	}
}

func (j *JsonToGo) parseScope(scope interface{}) {
	switch v := scope.(type) {
	case map[string]interface{}:
		j.parseMap(v)
	case []interface{}:
		j.parseArray(v)
	}
}

func (j *JsonToGo) parseMap(m map[string]interface{}) {
	j.append("struct {\n")
	j.tabs++
	for key, val := range m {
		j.indent(j.tabs)
		j.append(fmt.Sprintf("\n%s ", key))
		j.parseValue(val)
	}
	j.tabs--
	j.indent(j.tabs)
	j.append("}\n")
}

func (j *JsonToGo) parseArray(a []interface{}) {
	j.append("[]")
	if len(a) == 0 {
		j.append("interface{}")
		return
	}
	j.parseValue(a[0])
}

func (j *JsonToGo) parseValue(val interface{}) {
	switch v := val.(type) {
	case string:
		if isValidTime(v) {
			j.append("time.Time")
			return
		}
		j.append("string")
	case bool:
		j.append("bool")
	case float64:
		j.append("float64")
	case []interface{}:
		j.parseArray(v)
	case map[string]interface{}:
		j.parseMap(v)
	}
}

func isValidTime(s string) bool {
	_, err := time.Parse(time.RFC3339, s)
	return err == nil
}

// func getGoType(val any) string {
// 	if val == nil {
// 		return "any"
// 	}
// 	switch v := val.(type) {
// 	case string:
// 		if isValidTime(v) {
// 			return "time.Time"
// 		}
// 		return "string"
// 	case bool:
// 		return "bool"
// 	case float64:
// 		return "float64"
// 	case []interface{}:
// 		if len(v) == 0 {
// 			return "[]interface{}"
// 		}
// 		return "[]" + getGoType(v[0])
// 	case map[string]interface{}:
// 		return "struct"
// 	default:
// 		return "any"
// 	}
// }
